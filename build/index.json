{
    "2017-06-08-behavior-tree": {
        "name": "2017-06-08-behavior-tree",
        "stamp": "2017-6-8",
        "link": "../publish/2017-06-08-behavior-tree.html",
        "summary": "<a href=\"publish/2017-06-08-behavior-tree.html\"><h1>基于Erlang的行为树实现</h1>\n</a><ul>\n<li><a href=\"#什么是行为树\">什么是行为树</a></li>\n<li><a href=\"#为什么使用行为树\">为什么使用行为树</a></li>\n<li><a href=\"#组成部分\">组成部分</a></li>\n<li><a href=\"#具体实现\">具体实现</a></li>\n<li><a href=\"#参考文档\">参考文档</a></li>\n</ul>\n<h2><a name=\"什么是行为树\" class=\"anchor\" href=\"#什么是行为树\"><span class=\"header-link\"></span></a>什么是行为树</h2>\n<p>行为树，英文是Behavior Tree，简称BT，是由行为节点组成的树状结构。行为树的每个节点都会返回一个状态，成功，失败，运行，父节点根据子节点的返回值做出相应的决策。\n在游戏开发中，行为树主要用来实现怪物AI的行为决策，根据条件以及环境来决定怪物执行什么样的行为，如攻击，逃跑，巡逻，休息等。</p>\n<h2><a name=\"为什么使用行为树\" class=\"anchor\" href=\"#为什么使用行为树\"><span class=\"header-link\"></span></a>为什么使用行为树</h2>\n",
        "title": "基于Erlang的行为树实现"
    },
    "2017-06-21-selective-receive": {
        "name": "2017-06-21-selective-receive",
        "stamp": "2017-6-21",
        "link": "../publish/2017-06-21-selective-receive.html",
        "summary": "<a href=\"publish/2017-06-21-selective-receive.html\"><h1>Erlang的Selective Receive机制</h1>\n</a><ul>\n<li><a href=\"#selective-receive\">Selective Receive</a></li>\n<li><a href=\"#验证\">验证</a></li>\n<li><a href=\"#求证\">求证</a></li>\n<li><a href=\"#深入源码\">深入源码</a></li>\n<li><a href=\"#结论\">结论</a></li>\n<li><a href=\"#参考\">参考</a></li>\n</ul>\n<h2><a name=\"selective-receive\" class=\"anchor\" href=\"#selective-receive\"><span class=\"header-link\"></span></a>Selective Receive</h2>\n<p>Joe的Programming Erlang中讲到了Selective Receive的时候，提到了一个<code>save queue</code>的概念。</p>\n<blockquote>\n<pre><code>receive\n  P<span class=\"hljs-function\"><span class=\"hljs-title\">attern1</span> [<span class=\"hljs-keyword\">when</span> Guard1] -&gt;</span>\n  Expressions1;\n  P<span class=\"hljs-function\"><span class=\"hljs-title\">attern2</span> [<span class=\"hljs-keyword\">when</span> Guard2] -&gt;</span>\n  Expressions2;\n  ...\nafter\n  T<span class=\"hljs-function\"><span class=\"hljs-title\">ime</span> -&gt;</span>\n  ExpressionsTimeout\nend\n</code></pre><ul>\n<li>When we enter a receive statement, we start a timer (but only if an after section is present in the expression).</li>\n<li>Take the first message in the mailbox and try to match it against Pattern1, Pattern2, and so on. If the match succeeds, the message is removed from the mailbox, and the expressions following the pattern are evaluated.</li>\n<li>If none of the patterns in the receive statement matches the first message in the mailbox, then the first message is removed from the mailbox and put into a \"<em>save queue</em>.\" The second message in the mailbox is then tried. This procedure is repeated until a matching message is found or until all the messages in the mailbox have been examined.</li>\n<li>If none of the messages in the mailbox matches, then the process is suspended and will be rescheduled for execution the next time a new message is put in the mailbox. Note that when a new message arrives, the messages in the save queue are not rematched; only the new message is matched.</li>\n<li>As soon as a message has been matched, then all messages that have been put into the save queue are reentered into the mailbox in the order in which they arrived at the process. If a timer was set, it is cleared.</li>\n<li>If the timer elapses when we are waiting for a message, then evaluate the expressions ExpressionsTimeout and put any saved messages back into the mailbox in the order in which they arrived at the process.</li>\n</ul>\n</blockquote>\n",
        "title": "Erlang的Selective Receive机制"
    },
    "2017-07-05-beam-virtual-machine": {
        "name": "2017-07-05-beam-virtual-machine",
        "stamp": "2017-7-5",
        "link": "../publish/2017-07-05-beam-virtual-machine.html",
        "summary": "<a href=\"publish/2017-07-05-beam-virtual-machine.html\"><h1>Beam虚拟机</h1>\n</a><ul>\n<li><a href=\"#数据区\">数据区</a></li>\n<li><a href=\"#数据对象\">数据对象</a></li>\n<li><a href=\"#寄存器\">寄存器</a></li>\n<li><a href=\"#重要的指令\">重要的指令</a></li>\n<li><a href=\"#并发\">并发</a></li>\n<li><a href=\"#参考文档\">参考文档</a></li>\n</ul>\n<p>通过-S选项可以将erl源文件编译成汇编文件。</p>\n<pre><code><span class=\"hljs-meta\">$</span><span class=\"bash\"> erlc -S test.erl</span>\n</code></pre>\n<p>反编译 </p>\n",
        "title": "Beam虚拟机"
    },
    "2017-07-11-database-transaction": {
        "name": "2017-07-11-database-transaction",
        "stamp": "2017-7-11",
        "link": "../publish/2017-07-11-database-transaction.html",
        "summary": "<a href=\"publish/2017-07-11-database-transaction.html\"><h1>数据库事务</h1>\n</a><ul>\n<li><a href=\"#隔离级别\">隔离级别</a></li>\n<li><a href=\"#参考文档\">参考文档</a></li>\n</ul>\n<p>事务需要满足ACID特征。Mysql的innodb引擎支持事务。</p>\n<ul>\n<li>原子性，Atomicity, 一个事务是不可分割的整体，要么全部成功(committed)，要么全部失败(rolled back)，不存在部分成功。</li>\n<li>一致性，Consistency，数据总是从一致性的状态转移到另一个一致性的状态，总是处于有意义的状态。比如转账，A的钱减少，B的钱增加，总和是不变的。</li>\n<li>隔离性，Isolation，主要解决多个事务<strong>并发读写</strong>的问题，一个事务未提交，那么它对数据的修改对外是不可见的。</li>\n<li>持久性，Durability，一个事务一旦提交，对数据的影响的永久性的，就算断电，系统崩溃也是如此。</li>\n</ul>\n<p>四个性质最根本的是一致性，其他三个性质都是服务于一致性的。</p>\n",
        "title": "数据库事务"
    },
    "2017-07-15-erlang-code-loading": {
        "name": "2017-07-15-erlang-code-loading",
        "stamp": "2017-7-15",
        "link": "../publish/2017-07-15-erlang-code-loading.html",
        "summary": "<a href=\"publish/2017-07-15-erlang-code-loading.html\"><h1>Erlang代码加载模式</h1>\n</a><ul>\n<li><a href=\"#purge\">purge</a></li>\n<li><a href=\"#热更机制\">热更机制</a></li>\n<li><a href=\"#参考文档\">参考文档</a></li>\n</ul>\n<p>ERTS中有两种代码加载模式：</p>\n<ul>\n<li>interactive：代码第一次被引用的时候会去代码路径中搜索并加载。</li>\n<li>embedded：一开始就根据boot script来加载。</li>\n</ul>\n<p>code模块对外提供接口，code_server模块处理实际的工作，注册为code_server。维护一个私有ets表code。\n预加载的10个模块，包括erlang_prim_loader，erlang，init，prim_inet，prim_file等模块，需要被code_server用到的模块都属于预加载。</p>\n",
        "title": "Erlang代码加载模式"
    },
    "2017-08-26-erlang-memory-management": {
        "name": "2017-08-26-erlang-memory-management",
        "stamp": "2017-8-26",
        "link": "../publish/2017-08-26-erlang-memory-management.html",
        "summary": "<a href=\"publish/2017-08-26-erlang-memory-management.html\"><h1>Erlang Memory Management</h1>\n</a><ul>\n<li><a href=\"#概念\">概念</a></li>\n<li><a href=\"#各种分配器\">各种分配器</a></li>\n<li><a href=\"#allocation-strategy\">allocation strategy</a></li>\n<li><a href=\"#统计\">统计</a></li>\n<li><a href=\"#主要配置参数\">主要配置参数</a></li>\n<li><a href=\"#实例\">实例</a></li>\n<li><a href=\"#参考文档\">参考文档</a></li>\n</ul>\n<p>系统自带的分配器存在的缺点：</p>\n<ul>\n<li>小内存分配效率低。</li>\n<li>所有数据同样的分配策略，增加碎片。</li>\n<li>缺乏跨平台细粒度的统计</li>\n<li><code>+Mea</code> disable erts allocators and use malloc for everything</li>\n<li>多核内存管理更加重要也更加复杂</li>\n</ul>\n<h2><a name=\"概念\" class=\"anchor\" href=\"#概念\"><span class=\"header-link\"></span></a>概念</h2>\n",
        "title": "Erlang Memory Management"
    }
}