<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf8">
<link rel="stylesheet" type="text/css" href="./assets/css/bootstrap.css">
<link rel="stylesheet" type="text/css" href="./assets/css/github-markdown.css">
<link rel="stylesheet" type="text/css" href="./assets/css/main.css">
<script src="https://use.fontawesome.com/74835083f1.js"></script>
<title>Deng的梦呓</title>
</head>

<body>
<div class="container">
    <div class="main">
        <div class="banner">
            <h1 class="banner-header">Deng的梦呓</h1>
            <div class="banner-description">
                Erlang | 开发 | 感悟 | 生活
            </div>
            <div class="banner-icon btn-group">
                <a class="btn btn-default" href="https://wudeng.github.io">
                    <i class="fa fa-home fa-2x" aria-hidden="true"></i>
                </a>
                <a class="btn btn-default" href="https://github.com/wudeng">
                    <i class="fa fa-github fa-2x" aria-hidden="true"></i>
                </a>
                <a class="btn btn-default" href="./assets/rss.xml">
                    <i class="fa fa-rss fa-2x" aria-hidden="true"></i>
                </a>
                <!--
                <a class="btn btn-default" href="mailto:wudeng256#qq.com">
                    <i class="fa fa-envelope-o fa-2x" aria-hidden="true"></i>
                </a>
                -->
            </div>
        </div>

        <!-- auto complete by template replacement -->
        <div class="main-content markdown-body"><h1>Erlang代码加载模式</h1><ul>
<li><a href="#purge">purge</a></li>
<li><a href="#热更机制">热更机制</a></li>
<li><a href="#参考文档">参考文档</a></li>
</ul>
<p>ERTS中有两种代码加载模式：</p>
<ul>
<li>interactive：代码第一次被引用的时候会去代码路径中搜索并加载。</li>
<li>embedded：一开始就根据boot script来加载。</li>
</ul>
<p>code模块对外提供接口，code_server模块处理实际的工作，注册为code_server。维护一个私有ets表code。
预加载的10个模块，包括erlang_prim_loader，erlang，init，prim_inet，prim_file等模块，需要被code_server用到的模块都属于预加载。</p>
<pre><code>(<span class="hljs-selector-tag">dev</span>@<span class="hljs-keyword">127</span>.<span class="hljs-keyword">0</span>.<span class="hljs-keyword">0</span>.<span class="hljs-keyword">1</span>)<span class="hljs-keyword">1</span>&gt; erlang:pre_loaded().
[erts_internal,erlang,erl_prim_loader,prim_zip,zlib,
 prim_file,prim_inet,prim_eval,init,otp_ring0]
</code></pre><p>ERTS系统中，一个模块可以存在两个版本。新版本(current)和老版本(old)，两个版本都是有效的。
代码第一次加载进来的时候是新版本，当有新的代码加载的时候，新的代码变成新版本，原来的新版本变成老版本。当有第三个版本加载进来的时候，之前的老版本就需要被移除掉(purge)，
这样如果有进程还在执行老版本的代码，这些进程就会被无条件杀死。所以一般第一次热更新的时候是安全的，因为系统只有一个新版本的代码。第二次热更新如果使用强制更新就可能杀死
一些进程，要避免这种情况，一方面是在调用代码的时候使用全名函数，一方面在热更新的时候使用软更新(soft purge)。这样如果还有进程在执行老代码，就不会执行热更新。
OTP框架下的模板都是支持热更新的。</p>
<h2><a name="purge" class="anchor" href="#purge"><span class="header-link"></span></a>purge</h2><p>purge：是指将老版本的代码从系统中移除掉，如果仍有进程在执行老版本代码，则将这些进程杀掉。
soft_purge：尝试将老代码移除掉，如果仍有进程在执行老版本代码，则返回失败。</p>
<p>erlang:check_old_code(Mod) -&gt; true | false. 检查模块是否有老代码。</p>
<p>要找出仍在执行老代码的进程仍然需要遍历进程列表processes()，对进程执行erlang:check_process_code(Pid, Mod) -&gt; boolean()
返回进程时候仍在执行该模块的老代码。有三种情况下返回true：</p>
<ul>
<li>进程正在执行老代码。这种情况下是不管进程调用的全名函数短名函数。对于全名函数，当前这次执行完了下次就会切换到新代码，所以一开始返回true，后面就false了。对于短名函数则始终为true。</li>
<li>进程包含短名函数的引用。</li>
<li>进程包含引用短名函数的fun对象。比如其他模块发送了一个fun给进程执行，这个fun对象包含了模块的短名对象，那么执行fun对象期间返回true。</li>
</ul>
<p>杀进程。一般先monitor，再kill，等待接收moniter消息，确认当前进程杀死。因为被杀死的进程可能需要进行一些清理的行为，如果不等待它确认死亡就将执行后续操作如移除代码，可能会导致清理过程出现找不到代码的问题。</p>
<p>杀死进程的过程：</p>
<pre><code>%% do_purge(Module)
%%  Kill all processes running code <span class="hljs-keyword">from</span> *old* Module, <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> purge the
%%  <span class="hljs-built_in">module</span>. Return <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> any processes killed, <span class="hljs-keyword">else</span> <span class="hljs-literal">false</span>.

do_purge<span class="hljs-function"><span class="hljs-params">(Mod0)</span> -&gt;</span>
    Mod = to_atom(Mod0),
    <span class="hljs-keyword">case</span> erlang:check_old_code(Mod) <span class="hljs-keyword">of</span>
    <span class="hljs-literal">false</span><span class="hljs-function"> -&gt;</span> <span class="hljs-literal">false</span>;
    <span class="hljs-literal">true</span><span class="hljs-function"> -&gt;</span> do_purge(processes(), Mod, <span class="hljs-literal">false</span>)
    end.

do_purge<span class="hljs-function"><span class="hljs-params">([P|Ps], Mod, Purged)</span> -&gt;</span>
    <span class="hljs-keyword">case</span> erlang:check_process_code(P, Mod) <span class="hljs-keyword">of</span>
    <span class="hljs-literal">true</span><span class="hljs-function"> -&gt;</span>
        Ref = erlang:monitor(process, P),
        exit(P, kill),
        receive
        {<span class="hljs-string">'DOWN'</span>,Ref,process,_Pid,_}<span class="hljs-function"> -&gt;</span> ok
        end,
        do_purge(Ps, Mod, <span class="hljs-literal">true</span>);
    <span class="hljs-literal">false</span><span class="hljs-function"> -&gt;</span>
        do_purge(Ps, Mod, Purged)
    end;
do_purge<span class="hljs-function"><span class="hljs-params">([], Mod, Purged)</span> -&gt;</span>
    <span class="hljs-keyword">catch</span> erlang:purge_module(Mod),
    Purged.
</code></pre><p>直接purge有杀死进程的危险性，所以code_server也提供了soft_purge，如果有进程仍在执行老代码，则不移除老代码。</p>
<pre><code>%% do_soft_purge(Module)
%% Purge old code only <span class="hljs-keyword">if</span> <span class="hljs-literal">no</span> procs remain <span class="hljs-literal">that</span> run old code.
%% Return <span class="hljs-literal">true</span> <span class="hljs-keyword">in</span> <span class="hljs-literal">that</span> <span class="hljs-keyword">case</span>, <span class="hljs-literal">false</span> <span class="hljs-keyword">if</span> procs remain (<span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>
%% <span class="hljs-keyword">case</span> old code <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> purged)

do_soft_purge<span class="hljs-function"><span class="hljs-params">(Mod)</span> -&gt;</span>
    <span class="hljs-keyword">case</span> erlang:check_old_code(Mod) <span class="hljs-keyword">of</span>
    <span class="hljs-literal">false</span><span class="hljs-function"> -&gt;</span> <span class="hljs-literal">true</span>;
    <span class="hljs-literal">true</span><span class="hljs-function"> -&gt;</span> do_soft_purge(processes(), Mod)
    end.

do_soft_purge<span class="hljs-function"><span class="hljs-params">([P|Ps], Mod)</span> -&gt;</span>
    <span class="hljs-keyword">case</span> erlang:check_process_code(P, Mod) <span class="hljs-keyword">of</span>
    <span class="hljs-literal">true</span><span class="hljs-function"> -&gt;</span> <span class="hljs-literal">false</span>;
    <span class="hljs-literal">false</span><span class="hljs-function"> -&gt;</span> do_soft_purge(Ps, Mod)
    end;
do_soft_purge<span class="hljs-function"><span class="hljs-params">([], Mod)</span> -&gt;</span>
    <span class="hljs-keyword">catch</span> erlang:purge_module(Mod),
    <span class="hljs-literal">true</span>.
</code></pre><h2><a name="热更机制" class="anchor" href="#热更机制"><span class="header-link"></span></a>热更机制</h2><p>在开发环境中，可以使用Mochiweb的reloader模块来进行热更。reloader的实现机制主要是每隔一秒钟检测一次系统中加载的代码对应的beam文件时间戳，
如果发现时间戳从上次检测以来发生了变更，就执行热更新。在开发中使用起来非常方便。我们只需要编译代码，系统自动进行加载。
但是reloader的热更新用的是purge，也就是说如果你的进程不符合otp规范，比如进程的主循环用的是短名函数，那么就存在进程被杀死的风险。
reloader的核心代码如下：</p>
<pre><code>doit(<span class="hljs-keyword">From</span>, To) -&gt;
    [<span class="hljs-built_in">case</span> file:read_file_info(Filename) of
         {ok, #file_info{mtime = Mtime}} when Mtime &gt;= <span class="hljs-keyword">From</span>, Mtime &lt; To -&gt;
             reload(<span class="hljs-keyword">Module</span>);
         {ok, <span class="hljs-keyword">_</span>} -&gt;
             unmodified;
         {error, enoent} -&gt;
             %% The Erlang compiler deletes existing .beam files <span class="hljs-keyword">if</span>
             %% recompiling fails.  Maybe it's worth spitting out a
             %% warning here, but I'd want to limit it to just <span class="hljs-built_in">once</span>.
             gone;
         {error, Reason} -&gt;
             io:format(<span class="hljs-string">"Error reading ~s's file info: ~p~n"</span>,
                       [Filename, Reason]),
             error
     <span class="hljs-keyword">end</span> |<span class="hljs-type">| {Module</span>, Filename} &lt;- code:all_loaded(), is_list(Filename)].

reload(<span class="hljs-keyword">Module</span>) -&gt;
    io:format(<span class="hljs-string">"Reloading ~p ..."</span>, [<span class="hljs-keyword">Module</span>]),
    code:purge(<span class="hljs-keyword">Module</span>), %% **watch out**
    <span class="hljs-built_in">case</span> code:load_file(<span class="hljs-keyword">Module</span>) of
        {module, <span class="hljs-keyword">Module</span>} -&gt;
            io:format(<span class="hljs-string">" ok.~n"</span>),
            <span class="hljs-built_in">case</span> erlang:function_exported(<span class="hljs-keyword">Module</span>, test, <span class="hljs-number">0</span>) of
                true -&gt;
                    io:format(<span class="hljs-string">" - Calling ~p:test() ..."</span>, [<span class="hljs-keyword">Module</span>]),
                    <span class="hljs-built_in">case</span> catch <span class="hljs-keyword">Module</span>:test() of
                        ok -&gt;
                            io:format(<span class="hljs-string">" ok.~n"</span>),
                            reload;
                        Reason -&gt;
                            io:format(<span class="hljs-string">" fail: ~p.~n"</span>, [Reason]),
                            reload_but_test_failed
                    <span class="hljs-keyword">end</span>;
                false -&gt;
                    reload
            <span class="hljs-keyword">end</span>;
        {error, Reason} -&gt;
            io:format(<span class="hljs-string">" fail: ~p.~n"</span>, [Reason]),
            error
    <span class="hljs-keyword">end</span>.
</code></pre><p>实际上Erlang Shell中提供的函数的热更函数l(Module)实现就是直接purge，shell提供的函数实现在c.erl文件中，</p>
<pre><code><span class="hljs-function"><span class="hljs-title">l</span><span class="hljs-params">(Mod)</span></span> -&gt;
    <span class="hljs-selector-tag">code</span>:purge(Mod),
    <span class="hljs-selector-tag">code</span>:load_file(Mod).
</code></pre><p>直接load代码存在杀死进程的危险，所以一种安全的热更机制应该先尝试soft purge，如果成功，则加载代码，失败则放弃更新。</p>
<pre><code><span class="hljs-keyword">case</span> soft_purge(<span class="hljs-keyword">Mod</span>) <span class="hljs-keyword">of</span>
<span class="hljs-literal">true</span> -&gt; code:load_file(<span class="hljs-keyword">Mod</span>);
<span class="hljs-literal">false</span> -&gt; <span class="hljs-keyword">error</span> 
<span class="hljs-keyword">end</span>
</code></pre><h2><a name="参考文档" class="anchor" href="#参考文档"><span class="header-link"></span></a>参考文档</h2><ul>
<li><a href="http://erlang.org/doc/reference_manual/code_loading.html">Compilation and Code Loading</a></li>
<li><a href="https://github.com/rustyio/sync">sync</a></li>
</ul>
</div>

    </div>

</div>
</body>
</html>
