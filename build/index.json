{
    "2017-06-08-behavior-tree": {
        "name": "2017-06-08-behavior-tree",
        "stamp": "2017-6-8",
        "link": "../publish/2017-06-08-behavior-tree.html",
        "summary": "<a href=\"publish/2017-06-08-behavior-tree.html\"><h1>基于Erlang的行为树实现</h1>\n</a><ul>\n<li><a href=\"#什么是行为树\">什么是行为树</a></li>\n<li><a href=\"#为什么使用行为树\">为什么使用行为树</a></li>\n<li><a href=\"#组成部分\">组成部分</a></li>\n<li><a href=\"#具体实现\">具体实现</a></li>\n<li><a href=\"#参考文档\">参考文档</a></li>\n</ul>\n<h2><a name=\"什么是行为树\" class=\"anchor\" href=\"#什么是行为树\"><span class=\"header-link\"></span></a>什么是行为树</h2>\n<p>行为树，英文是Behavior Tree，简称BT，是由行为节点组成的树状结构。行为树的每个节点都会返回一个状态，成功，失败，运行，父节点根据子节点的返回值做出相应的决策。\n在游戏开发中，行为树主要用来实现怪物AI的行为决策，根据条件以及环境来决定怪物执行什么样的行为，如攻击，逃跑，巡逻，休息等。</p>\n<h2><a name=\"为什么使用行为树\" class=\"anchor\" href=\"#为什么使用行为树\"><span class=\"header-link\"></span></a>为什么使用行为树</h2>\n",
        "title": "基于Erlang的行为树实现"
    },
    "2017-06-21-selective-receive": {
        "name": "2017-06-21-selective-receive",
        "stamp": "2017-6-21",
        "link": "../publish/2017-06-21-selective-receive.html",
        "summary": "<a href=\"publish/2017-06-21-selective-receive.html\"><h1>Erlang的Selective Receive机制</h1>\n</a><ul>\n<li><a href=\"#selective-receive\">Selective Receive</a></li>\n<li><a href=\"#验证\">验证</a></li>\n<li><a href=\"#求证\">求证</a></li>\n<li><a href=\"#深入源码\">深入源码</a></li>\n<li><a href=\"#结论\">结论</a></li>\n<li><a href=\"#参考\">参考</a></li>\n</ul>\n<h2><a name=\"selective-receive\" class=\"anchor\" href=\"#selective-receive\"><span class=\"header-link\"></span></a>Selective Receive</h2>\n<p>Joe的Programming Erlang中讲到了Selective Receive的时候，提到了一个<code>save queue</code>的概念。</p>\n<blockquote>\n<pre><code>receive\n  P<span class=\"hljs-function\"><span class=\"hljs-title\">attern1</span> [<span class=\"hljs-keyword\">when</span> Guard1] -&gt;</span>\n  Expressions1;\n  P<span class=\"hljs-function\"><span class=\"hljs-title\">attern2</span> [<span class=\"hljs-keyword\">when</span> Guard2] -&gt;</span>\n  Expressions2;\n  ...\nafter\n  T<span class=\"hljs-function\"><span class=\"hljs-title\">ime</span> -&gt;</span>\n  ExpressionsTimeout\nend\n</code></pre><ul>\n<li>When we enter a receive statement, we start a timer (but only if an after section is present in the expression).</li>\n<li>Take the first message in the mailbox and try to match it against Pattern1, Pattern2, and so on. If the match succeeds, the message is removed from the mailbox, and the expressions following the pattern are evaluated.</li>\n<li>If none of the patterns in the receive statement matches the first message in the mailbox, then the first message is removed from the mailbox and put into a \"<em>save queue</em>.\" The second message in the mailbox is then tried. This procedure is repeated until a matching message is found or until all the messages in the mailbox have been examined.</li>\n<li>If none of the messages in the mailbox matches, then the process is suspended and will be rescheduled for execution the next time a new message is put in the mailbox. Note that when a new message arrives, the messages in the save queue are not rematched; only the new message is matched.</li>\n<li>As soon as a message has been matched, then all messages that have been put into the save queue are reentered into the mailbox in the order in which they arrived at the process. If a timer was set, it is cleared.</li>\n<li>If the timer elapses when we are waiting for a message, then evaluate the expressions ExpressionsTimeout and put any saved messages back into the mailbox in the order in which they arrived at the process.</li>\n</ul>\n</blockquote>\n",
        "title": "Erlang的Selective Receive机制"
    },
    "2017-07-05-beam-virtual-machine": {
        "name": "2017-07-05-beam-virtual-machine",
        "stamp": "2017-7-5",
        "link": "../publish/2017-07-05-beam-virtual-machine.html",
        "summary": "<a href=\"publish/2017-07-05-beam-virtual-machine.html\"><h1>Beam虚拟机</h1>\n</a><ul>\n<li><a href=\"#数据区\">数据区</a></li>\n<li><a href=\"#数据对象\">数据对象</a></li>\n<li><a href=\"#寄存器\">寄存器</a></li>\n<li><a href=\"#重要的指令\">重要的指令</a></li>\n<li><a href=\"#并发\">并发</a></li>\n<li><a href=\"#参考文档\">参考文档</a></li>\n</ul>\n<p>通过-S选项可以将erl源文件编译成汇编文件。</p>\n<pre><code><span class=\"hljs-meta\">$</span><span class=\"bash\"> erlc -S test.erl</span>\n</code></pre>\n<p>反编译 </p>\n",
        "title": "Beam虚拟机"
    },
    "2017-07-11-database-transaction": {
        "name": "2017-07-11-database-transaction",
        "stamp": "2017-7-11",
        "link": "../publish/2017-07-11-database-transaction.html",
        "summary": "<a href=\"publish/2017-07-11-database-transaction.html\"><h1>数据库事务</h1>\n</a><ul>\n<li><a href=\"#隔离级别\">隔离级别</a></li>\n<li><a href=\"#参考文档\">参考文档</a></li>\n</ul>\n<p>事务需要满足ACID特征。Mysql的innodb引擎支持事务。</p>\n<ul>\n<li>原子性，Atomicity, 一个事务是不可分割的整体，要么全部成功(committed)，要么全部失败(rolled back)，不存在部分成功。</li>\n<li>一致性，Consistency，数据总是从一致性的状态转移到另一个一致性的状态，总是处于有意义的状态。比如转账，A的钱减少，B的钱增加，总和是不变的。</li>\n<li>隔离性，Isolation，主要解决多个事务<strong>并发读写</strong>的问题，一个事务未提交，那么它对数据的修改对外是不可见的。</li>\n<li>持久性，Durability，一个事务一旦提交，对数据的影响的永久性的，就算断电，系统崩溃也是如此。</li>\n</ul>\n<p>四个性质最根本的是一致性，其他三个性质都是服务于一致性的。</p>\n",
        "title": "数据库事务"
    },
    "2017-07-15-erlang-code-loading": {
        "name": "2017-07-15-erlang-code-loading",
        "stamp": "2017-7-15",
        "link": "../publish/2017-07-15-erlang-code-loading.html",
        "summary": "<a href=\"publish/2017-07-15-erlang-code-loading.html\"><h1>Erlang代码加载模式</h1>\n</a><ul>\n<li><a href=\"#purge\">purge</a></li>\n<li><a href=\"#热更机制\">热更机制</a></li>\n<li><a href=\"#参考文档\">参考文档</a></li>\n</ul>\n<p>ERTS中有两种代码加载模式：</p>\n<ul>\n<li>interactive：代码第一次被引用的时候会去代码路径中搜索并加载。</li>\n<li>embedded：一开始就根据boot script来加载。</li>\n</ul>\n<p>code模块对外提供接口，code_server模块处理实际的工作，注册为code_server。维护一个私有ets表code。\n预加载的10个模块，包括erlang_prim_loader，erlang，init，prim_inet，prim_file等模块，需要被code_server用到的模块都属于预加载。</p>\n",
        "title": "Erlang代码加载模式"
    },
    "2017-08-26-erlang-memory-management": {
        "name": "2017-08-26-erlang-memory-management",
        "stamp": "2017-8-26",
        "link": "../publish/2017-08-26-erlang-memory-management.html",
        "summary": "<a href=\"publish/2017-08-26-erlang-memory-management.html\"><h1>Erlang Memory Management</h1>\n</a><ul>\n<li><a href=\"#概念\">概念</a></li>\n<li><a href=\"#各种分配器\">各种分配器</a></li>\n<li><a href=\"#分配策略as\">分配策略(as)</a></li>\n<li><a href=\"#统计\">统计</a></li>\n<li><a href=\"#主要配置参数\">主要配置参数</a></li>\n<li><a href=\"#实例\">实例</a></li>\n<li><a href=\"#参考文档\">参考文档</a></li>\n</ul>\n<p>系统自带的分配器存在的缺点：</p>\n<ul>\n<li>小内存分配效率低。</li>\n<li>所有数据同样的分配策略，增加碎片。</li>\n<li>缺乏跨平台细粒度的统计</li>\n<li><code>+Mea</code> disable erts allocators and use malloc for everything</li>\n<li>多核内存管理更加重要也更加复杂</li>\n</ul>\n<h2><a name=\"概念\" class=\"anchor\" href=\"#概念\"><span class=\"header-link\"></span></a>概念</h2>\n",
        "title": "Erlang Memory Management"
    },
    "2017-09-01-monster-steering-behavior": {
        "name": "2017-09-01-monster-steering-behavior",
        "stamp": "2017-9-1",
        "link": "../publish/2017-09-01-monster-steering-behavior.html",
        "summary": "<a href=\"publish/2017-09-01-monster-steering-behavior.html\"><h1>怪物包围算法</h1>\n</a><ul>\n<li><a href=\"#算法思路\">算法思路</a></li>\n<li><a href=\"#具体实现\">具体实现</a></li>\n</ul>\n<p>ARPG游戏中经常出现多个怪物追着玩家跑的情况，如果怪物始终瞄着玩家的位置移动，那么很容易就出现怪物扎堆的情况。\n本文探讨并实现了一个位置管理算法，来解决这个问题。</p>\n<h2><a name=\"算法思路\" class=\"anchor\" href=\"#算法思路\"><span class=\"header-link\"></span></a>算法思路</h2>\n<p>我们的思路是：如果玩家已经在攻击范围内，直接攻击。否则怪物向玩家移动，形成一个以攻击距离为半径，玩家为圆心的包围圈。\n在移动过程中，怪物优先选择怪物所在位置与玩家连线跟圆的交点。 如果交点被占据，则向两边搜索新的位置，直到找到一个位置为止。</p>\n",
        "title": "怪物包围算法"
    }
}