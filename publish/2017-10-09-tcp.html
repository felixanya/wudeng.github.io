<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf8">
<link rel="stylesheet" type="text/css" href="./assets/css/bootstrap.css">
<link rel="stylesheet" type="text/css" href="./assets/css/github-markdown.css">
<link rel="stylesheet" type="text/css" href="./assets/css/main.css">
<script src="https://use.fontawesome.com/74835083f1.js"></script>
<title>Deng的梦呓</title>
</head>

<body>
<div class="container">
    <div class="main">
        <div class="banner">
            <h1 class="banner-header">Deng的梦呓</h1>
            <div class="banner-description">
                Erlang | 开发 | 感悟 | 生活
            </div>
            <div class="banner-icon btn-group">
                <a class="btn btn-default" href="https://wudeng.github.io">
                    <i class="fa fa-home fa-2x" aria-hidden="true"></i>
                </a>
                <a class="btn btn-default" href="https://github.com/wudeng">
                    <i class="fa fa-github fa-2x" aria-hidden="true"></i>
                </a>
                <a class="btn btn-default" href="./assets/rss.xml">
                    <i class="fa fa-rss fa-2x" aria-hidden="true"></i>
                </a>
                <a class="btn btn-default" href="mailto:wudeng256@gmail.com">
                    <i class="fa fa-envelope-o fa-2x" aria-hidden="true"></i>
                </a>
            </div>
        </div>

        <!-- auto complete by template replacement -->
        <div class="main-content markdown-body"><h1>TCP PROTOCOL</h1><ul>
<li><a href="#tcp-header">TCP HEADER</a><ul>
<li><a href="#sack">sack</a></li>
</ul>
</li>
<li><a href="#tcp-状态转移">TCP 状态转移</a><ul>
<li><a href="#timewait">TIME_WAIT</a></li>
</ul>
</li>
<li><a href="#tcp-流控">TCP 流控</a><ul>
<li><a href="#超时重传rtoretransmission-timeout">超时重传RTO（Retransmission timeout）</a></li>
<li><a href="#tcp-拥塞控制算法-congestion-control-algorithm">tcp 拥塞控制算法 congestion control algorithm</a></li>
</ul>
</li>
<li><a href="#随机早期检测red">随机早期检测RED</a></li>
<li><a href="#参考文献">参考文献</a></li>
</ul>
<p>特点，</p>
<ul>
<li>面向连接，一对一，所以基于广播和多播的应用程序不能使用TCP服务。而无连接的UDP则非常适合广播和多播。</li>
<li>字节流，TCP 字节流，send()写recv()读次数没有固定关系，UDP 数据报，sendto()写recvfrom()读次数相同。</li>
<li>可靠传输。</li>
</ul>
<h2><a name="tcp-header" class="anchor" href="#tcp-header"><span class="header-link"></span></a>TCP HEADER</h2><p>!<img src="../data/2017-10-09-tcp/tcp-header.png" alt="tcp-header"></p>
<p>32位序号sequence number, ISN + byte offset of the first byte in the packet
ISN initial sequence number, random generated </p>
<p>4 bit header length: unit 32bit, max = 4 * 15 = 60
6 Flags:</p>
<ul>
<li>URG</li>
<li>ACK</li>
<li>PSH </li>
<li>RST</li>
<li>SYN</li>
<li>FIN</li>
</ul>
<p>RWND receiver window
checksum crc(header + data)</p>
<p>options &lt;= 40 byte</p>
<p>!<img src="../data/2017-10-09-tcp/tcp-options.png" alt="tcp-options"></p>
<p>kind 1, length 1, info n
kind:</p>
<ul>
<li>0 terminate</li>
<li>1 nop</li>
<li>2 MSS, MTU - 40, typical 1460(1500 - 40)</li>
<li>3 window scale, 0~14, /proc/sys/net/ipv4/tcp_window_scaling only for syn, rfc1323</li>
<li>4 sack-permitted only in syn, /proc/sys/net/ipv4/tcp_sack</li>
<li>5 sack content</li>
<li>8 timestamp for rtt calculation /proc/sys/net/ipv4/tcp_timestamps</li>
</ul>
<h3><a name="sack" class="anchor" href="#sack"><span class="header-link"></span></a>sack</h3><p>tcp selective acknowledgments
采用累积确认，发生丢包以后，发送端要么重传所有从丢包的包以后的所有包，要么发送丢失的包以后再等待一个RTT时间来发现下一个要传的包。
选择确认机制就是为了解决这个问题。接收端可以告诉发送端哪些包收到了，发送端只需要发送未收到的包即可。提高了效率。</p>
<h2><a name="tcp-状态转移" class="anchor" href="#tcp-状态转移"><span class="header-link"></span></a>TCP 状态转移</h2><p>!<img src="../data/2017-10-09-tcp/tcp_status.jpg" alt="tcp-status"></p>
<h3><a name="time_wait" class="anchor" href="#time_wait"><span class="header-link"></span></a>TIME_WAIT</h3><p>2*MSL(Maximum Segment Life) 报文段最大生存时间，rfc1122建议2min</p>
<p>存在的原因：</p>
<ul>
<li>可靠的终止TCP连接。</li>
<li>保证让迟来的TCP报文段有足够的时间被识别并丢弃。</li>
</ul>
<p>服务器主动关闭连接后，监听的端口处于TIME_WAIT状态导致它不能立即重启，需要设置socket选项SO_REUSEADDR来强制进程立即使用处于TIME_WAIT状态占用的端口。</p>
<p>正常终止连接需要四步握手。TCP还提供了异常终止连接的办法，即给对方发送一个复位报文段。一旦发送了复位报文段，发送端素有排队等待发送的数据都将被丢弃。</p>
<p>应用程序可以使用socket选项SO_LINGER来发送复位报文段，以异常终止一个连接。</p>
<h2><a name="tcp-流控" class="anchor" href="#tcp-流控"><span class="header-link"></span></a>TCP 流控</h2><h3><a name="超时重传rto（retransmission-timeout）" class="anchor" href="#超时重传rto（retransmission-timeout）"><span class="header-link"></span></a>超时重传RTO（Retransmission timeout）</h3><p>RTO计算方法见<a href="https://tools.ietf.org/rfc/rfc6298.txt">Computing TCP&#39;s Retransmission Timer</a>，主要维护两个变量：</p>
<ul>
<li>SRTT: smoothed round-trip time</li>
<li>RTTVAR: round-trip time variation</li>
</ul>
<p>计算过程如下：</p>
<ul>
<li><p>初始化先设置：</p>
<pre><code><span class="hljs-attribute">RTO</span> = <span class="hljs-number">1</span> or <span class="hljs-number">3</span> seconds<span class="hljs-comment">;</span>
</code></pre></li>
<li><p>报文超时，重传以后设置改报文新的超时时间为：</p>
<pre><code><span class="hljs-attr">RTO</span> = RTO * <span class="hljs-number">2</span> (back <span class="hljs-literal">off</span> the timer)
</code></pre></li>
<li><p>更新srtt和rttvar之后，计算新的rro：</p>
<pre><code><span class="hljs-attr">RTO</span> = SRTT + max(G, K*TRRVAR);
RTO &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">then</span> <span class="hljs-attr">RTO</span> = <span class="hljs-number">1</span>;
RTO &gt; <span class="hljs-number">60</span> <span class="hljs-keyword">then</span> <span class="hljs-attr">RTO</span> = <span class="hljs-number">60</span>;
</code></pre></li>
</ul>
<p>srtt和rttvar的计算过程如下：</p>
<ul>
<li>收到第一个ACK以后，设置：</li>
</ul>
<pre><code><span class="hljs-attribute">SRTT</span> = R<span class="hljs-comment">;</span>
<span class="hljs-attribute">RTTVAR</span> = R / <span class="hljs-number">2</span><span class="hljs-comment">;</span>
</code></pre><ul>
<li>收到后续的ACK，<strong>依次</strong>设置：<pre><code>RTTVAR = (1 - bata) * RTTVAR + bata * |SRTT - R&#39;|;
SRTT = (1 - alpha) * SRTT + alpha * R&#39;;
</code></pre>其中 <pre><code>alpha = <span class="hljs-number">1</span>/<span class="hljs-number">8</span>, beta = <span class="hljs-number">1</span>/<span class="hljs-number">4</span>
</code></pre></li>
</ul>
<p>不能用重传的包来计算rtt, 因为无法确定包是哪个时间点发出的，除非包本身有timestamp。</p>
<h3><a name="tcp-拥塞控制算法-congestion-control-algorithm" class="anchor" href="#tcp-拥塞控制算法-congestion-control-algorithm"><span class="header-link"></span></a>tcp 拥塞控制算法 congestion control algorithm</h3><p>提高网络利用率，降低丢包率，保证公平性。RFC5681</p>
<ul>
<li>慢启动和拥塞避免 slow start and congestion avoidance</li>
<li>快速重传和快速恢复 fast retransmit / fast recovery</li>
</ul>
<p>SACK 选择性确认 selective acknowledgment 可选项</p>
<p>/proc/sys/net/ipv4/tcp_sack</p>
<p>Implementation</p>
<ul>
<li>reno</li>
<li>vegas</li>
<li>cubic 看了下centos下都是cubic</li>
</ul>
<p>$ sysctl -a | grep congestion_control
net.ipv4.tcp_congestion_control = cubic
net.ipv4.tcp_available_congestion_control = cubic reno
net.ipv4.tcp_allowed_congestion_control = cubic reno</p>
<p>/proc/sys/net/ipv4/tcp_congestion_control</p>
<p>if CWND &lt; ssthresh
slow start cwnd每个rtt扩大一倍，指数扩大</p>
<ul>
<li>IW</li>
<li>CWND += min(N, SMSS)</li>
</ul>
<p>if CWND &gt; ssthresh</p>
<ul>
<li>CWND += SMSS*SMSS/CWND cwnd每个rtt加1</li>
</ul>
<p>早期拥塞避免阶段的cwnd计算公式为：<code>cwnd += (MSS * MSS / cwnd) + MSS/8</code>，
rfc2525指出了Extra additive constant in congestion avoidance，带来的问题，
即公式后面多余的部分会导致一个RTT内多个包丢失而无法通过快速重传恢复，从而导致超时重传，从而降低性能。 
正确的做法应该是去掉后面的部分：<code>cwnd += (MSS * MSS / cwnd)</code>。</p>
<p>如果CWND=ssthresh，慢启动或者拥塞避免随意。</p>
<p>发送端判断拥塞：</p>
<ul>
<li>传输超时，tcp重传定时器溢出：慢启动和拥塞避免<ul>
<li>ssthresh = max(FlightSize/2, 2*MSS)</li>
<li>CWND &lt;= SMSS</li>
<li>再次进入慢启动</li>
</ul>
</li>
</ul>
<p>!<img src="../data/2017-10-09-tcp/slow-start-and-congestion-avoidance.png" alt="slow-start-and-congestion-avoidance"></p>
<ul>
<li>接收到重复的确认报文：快速重传，快速恢复<ul>
<li>接收端收到失序报文立即发送重复确认，而不必等待自己发送数据时捎带确认 </li>
<li>发送端收到前两个重复确认时，在允许的情况下应该发送一个之前尚未发送的数据包，(FlightSize &lt;= cwnd+2*MSS), CWND保持不变。</li>
<li>发送端收到3个重复确认报文立即重发对方未收到的报文，而不必等待超时。 
ssthresh=max(FlightSize/2, 2<em>MSS), CWND = ssthresh + 3</em>MSS，加3是因为收到了3个重复ack报文，意味着有三个报文离开了网络。</li>
<li>每收到一个重复确认：CWND = CWND + SMSS，每收到一个重复确认，那么有一个报文离开了网络。</li>
<li>收到新数据确认：CWND = ssthresh</li>
<li>快速重传和快速恢复完成之后，恢复到拥塞避免阶段</li>
</ul>
</li>
</ul>
<p>!<img src="../data/2017-10-09-tcp/fast-retransmit.png" alt="fast-retransmit">
!<img src="../data/2017-10-09-tcp/fast-recovery.png" alt="fast-recovery"></p>
<h2><a name="随机早期检测red" class="anchor" href="#随机早期检测red"><span class="header-link"></span></a>随机早期检测RED</h2><p>random early detection</p>
<p>网络层的策略对拥塞控制算法影响最大的就是路由器的丢弃策略。在简单的情况下，路由器通常按照先进先出的策略处理到来的分组。
当路由器的缓存装不下分组的时候就丢弃到来的分组，这就叫尾部丢弃策略。这样会导致分组丢失，发送方认为网络产生阻塞。
当网络中存在很多TCP连接，若发生路由器的尾部丢弃，可能影响很多条TCP连接，结果就是很多TCP同一时间进入slow start状态。
这种情况称为全局同步。全局同步回事网络的通信量突然下降很多，而在网络恢复正常以后，通信量又突然增大很多。</p>
<p>为避免产生网络中的全局同步现象，路由器采用随机早期检测算法：
路由器的队列维持两个参数，队列最小门限min和最大门限max，每当一个分组到来的时候，RED就计算平均队列长度。然后分情况对待到来的分组：</p>
<ul>
<li>平均队列长度小于最小门限，将新分组加入队列排队。</li>
<li>平均队列长度在min和max之间，按照概率丢弃分组。</li>
<li>平均队列长度大于max，丢弃分组。
以概率p随机丢弃分组，让拥塞控制只在个别的TCP连接上执行，因而避免全局性的拥塞控制。
!<img src="../data/2017-10-09-tcp/red.png" alt="red"></li>
</ul>
<p>RED的关键就是选择三个参数：最小门限，最大门限，丢弃概率以及计算平均队列长度。
平均队列长度采用加权的方法计算，跟计算RTT的策略一样。
!<img src="../data/2017-10-09-tcp/red-la.png" alt="red-la"></p>
<h2><a name="参考文献" class="anchor" href="#参考文献"><span class="header-link"></span></a>参考文献</h2><ul>
<li><a href="https://stackoverflow.com/questions/1803566/what-is-the-cost-of-many-time-wait-on-the-server-side">https://stackoverflow.com/questions/1803566/what-is-the-cost-of-many-time-wait-on-the-server-side</a></li>
<li><a href="https://tools.ietf.org/html/rfc5681">TCP Congestion Control</a></li>
<li><a href="https://tools.ietf.org/rfc/rfc6298.txt">Computing TCP&#39;s Retransmission Timer</a></li>
<li>Linux高性能服务器编程</li>
</ul>
</div>

    </div>

</div>
</body>
</html>
